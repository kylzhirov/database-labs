postgres=# SELECT COUNT(*) AS total_employees
FROM employees;
 total_employees 
-----------------
               6
(1 row)

postgres=# UPDATE employees
SET email = 'alice22@gmail.com'
WHERE id = 1;

UPDATE employees
SET email = 'david4321@gmail.com'
WHERE id = 4;
UPDATE 1
UPDATE 1

postgres=# SELECT COUNT(email) AS employees_with_email
FROM employees;
 employees_with_email 
----------------------
                    2
(1 row)


postgres=# SELECT COUNT(DISTINCT department) AS unique_departments
FROM employees;
 unique_departments 
--------------------
                  3
(1 row)

postgres=# -- Calculate total salary expenditure
SELECT SUM(salary) AS total_salaries
FROM employees;
 total_salaries 
----------------
      390000.00
(1 row)

postgres=# CREATE TABLE sales_data (
    id SERIAL PRIMARY KEY,
    department VARCHAR(50),
    sales_amount DECIMAL(10, 2)
);
CREATE TABLE
postgres=# INSERT INTO sales_data (department, sales_amount) VALUES
('Sales', 100000.00),
('IT', 150000.00),
('HR', 140000.00);
INSERT 0 3

postgres=# -- Calculate total sales by department
SELECT department, SUM(sales_amount) AS total_sales
FROM sales_data
GROUP BY department;
 department | total_sales 
------------+-------------
 Sales      |   100000.00
 IT         |   150000.00
 HR         |   140000.00
(3 rows)

postgres=# -- Calculate average salary
SELECT AVG(salary) AS average_salary
FROM employees;
   average_salary   
--------------------
 65000.000000000000
(1 row)

postgres=# ALTER TABLE employees ADD COLUMN age INT;
ALTER TABLE
postgres=# UPDATE employees SET age = '23' WHERE id=2;
UPDATE 1
postgres=# UPDATE employees SET age = '19' WHERE id=3;
UPDATE 1
postgres=# UPDATE employees SET age = '26' WHERE id=5;
UPDATE 1
postgres=# UPDATE employees SET age = '22' WHERE id=6;
UPDATE 1
postgres=# UPDATE employees SET age = '20' WHERE id=1;
UPDATE 1
postgres=# UPDATE employees SET age = '32' WHERE id=4;
UPDATE 1
postgres=# SELECT * FROM TABLE employees ;
ERROR:  syntax error at or near "TABLE"
LINE 1: SELECT * FROM TABLE employees ;
                      ^
postgres=# SELECT * FROM employees ;
 id |  name   |  salary  | department |        email        | age 
----+---------+----------+------------+---------------------+-----
  2 | Bob     | 75000.00 | Sales      |                     |  23
  3 | Charlie | 55000.00 | IT         |                     |  19
  5 | Eve     | 62000.00 | HR         |                     |  26
  6 | Frank   | 58000.00 | HR         |                     |  22
  1 | Alice   | 60000.00 | Sales      | alice22@gmail.com   |  20
  4 | David   | 80000.00 | IT         | david4321@gmail.com |  32
(6 rows)

SELECT department, AVG(age) AS avg_age
FROM employees
GROUP BY department;
 department |       avg_age       
------------+---------------------
 Sales      | 21.5000000000000000
 IT         | 25.5000000000000000
 HR         | 24.0000000000000000
(3 rows)

postgres=# -- Find highest and lowest salaries
SELECT
MAX(salary) AS highest_salary,
MIN(salary) AS lowest_salary
FROM employees;
 highest_salary | lowest_salary 
----------------+---------------
       80000.00 |      55000.00
(1 row)

postgres=# UPDATE employees
SET hire_date = '2023-04-15'
WHERE id = 1;
UPDATE 1
postgres=# UPDATE employees
SET hire_date = '2024-05-15'
WHERE id = 2;
UPDATE 1
postgres=# UPDATE employees
SET hire_date = '2024-06-23'
WHERE id = 3;
UPDATE 1
postgres=# UPDATE employees
SET hire_date = '2022-06-23'
WHERE id = 4;
UPDATE 1
postgres=# UPDATE employees
SET hire_date = '2021-06-23'
WHERE id = 5;
UPDATE 1
postgres=# UPDATE employees
SET hire_date = '2021-06-23'
WHERE id = 6;
UPDATE 1
postgres=# UPDATE employees
SET hire_date = '2020-06-23'
WHERE id = 7;
UPDATE 0

postgres=# -- Find the most recent hire date by department
SELECT department, MAX(hire_date) AS latest_hire
FROM employees
GROUP BY department;
 department | latest_hire 
------------+-------------
 Sales      | 2024-05-15
 IT         | 2024-06-23
 HR         | 2021-06-23
(3 rows)

postgres=# -- List all employees in each department as a comma-separated string
SELECT department, STRING_AGG(name, ', ') AS employee_names
FROM employees
GROUP BY department;
 department | employee_names 
------------+----------------
 Sales      | Alice, Bob
 IT         | Charlie, David
 HR         | Eve, Frank
(3 rows)

postgres=# CREATE TABLE employee_skills (
    employee_id INT NOT NULL,
    skill_name VARCHAR(50) NOT NULL,
    FOREIGN KEY (employee_id) REFERENCES employees(id)
);
CREATE TABLE
postgres=# INSERT INTO employee_skills (employee_id, skill_name)
VALUES
(2, 'Leadership'),
(2, 'Data Analysis');
INSERT 0 2
postgres=# -- Create a list of skills per employee (ordered alphabetically)
SELECT employee_id, STRING_AGG(skill_name, ', ' ORDER BY skill_name) AS
skills
FROM employee_skills
GROUP BY employee_id;
 employee_id |          skills           
-------------+---------------------------
           2 | Data Analysis, Leadership
(1 row)


postgres=# SELECT department, ARRAY_AGG(salary) AS salary_array
FROM employees
GROUP BY department;
 department |    salary_array     
------------+---------------------
 Sales      | {60000.00,75000.00}
 IT         | {55000.00,80000.00}
 HR         | {62000.00,58000.00}
(3 rows)

SELECT department, ARRAY_AGG(name ORDER BY name) AS employees
FROM employees
GROUP BY department;
 department |    employees    
------------+-----------------
 HR         | {Eve,Frank}
 IT         | {Charlie,David}
 Sales      | {Alice,Bob}
(3 rows)

postgres=# -- Standard deviation and variance
SELECT
department,
STDDEV(salary) AS salary_std_dev,
VARIANCE(salary) AS salary_variance
FROM employees
GROUP BY department;
 department |   salary_std_dev   |    salary_variance     
------------+--------------------+------------------------
 Sales      | 10606.601717798213 | 112500000.000000000000
 IT         |     17677.66952966 |     312500000.00000000
 HR         |  2828.427124746190 |   8000000.000000000000
(3 rows)

postgres=# -- Correlation coefficient between two numeric columns
SELECT CORR(experience_years, salary) AS experience_salary_correlation
FROM employees;
 experience_salary_correlation 
-------------------------------
            0.4631968904032512
(1 row)

postgres=# ALTER TABLE products ADD COLUMN category VARCHAR(100);
ALTER TABLE

postgres=# UPDATE products SET category='Electronics' WHERE product_id=1;
UPDATE 1

postgres=# UPDATE products SET category='Accessories' WHERE product_id IN (2,3);
UPDATE 2

postgres=# -- Sales summary by product category
SELECT
category,
COUNT(*) AS number_of_products,
SUM(price) AS total_value,
AVG(price) AS average_price
FROM products
GROUP BY category;
  category   | number_of_products | total_value |    average_price     
-------------+--------------------+-------------+----------------------
 Electronics |                  1 |      699.99 | 699.9900000000000000
 Accessories |                  2 |      134.50 |  67.2500000000000000
(2 rows)


postgres=# CREATE TABLE sales (
    sale_id SERIAL PRIMARY KEY,
    sale_date DATE NOT NULL,
    amount DECIMAL(10, 2) NOT NULL
);
CREATE TABLE
postgres=# INSERT INTO sales (sale_date, amount) VALUES
('2021-01-15', 150.00),
('2021-01-20', 200.00),
('2021-02-10', 300.00),
('2021-03-05', 250.00);
INSERT 0 4

postgres=# -- Sales analysis by year and quarter
SELECT
EXTRACT(YEAR FROM sale_date) AS year,
EXTRACT(QUARTER FROM sale_date) AS quarter,
COUNT(*) AS total_sales,
SUM(amount) AS total_revenue
FROM sales
GROUP BY EXTRACT(YEAR FROM sale_date), EXTRACT(QUARTER FROM sale_date)
ORDER BY year, quarter;
 year | quarter | total_sales | total_revenue 
------+---------+-------------+---------------
 2021 |       1 |           4 |        900.00
(1 row)

postgres=# SELECT
CASE
WHEN age < 30 THEN 'Under 30'
WHEN age BETWEEN 30 AND 50 THEN '30-50'
ELSE 'Over 50'
END AS age_group,
COUNT(*) AS employee_count,
AVG(salary) AS avg_salary
FROM employees
GROUP BY
CASE
WHEN age < 30 THEN 'Under 30'
WHEN age BETWEEN 30 AND 50 THEN '30-50'
ELSE 'Over 50'
END;
 age_group | employee_count |     avg_salary     
-----------+----------------+--------------------
 Under 30  |              5 | 62000.000000000000
 30-50     |              1 | 80000.000000000000
(2 rows)

postgres=# SELECT
department,
COUNT(*) AS employee_count
FROM employees
GROUP BY department
HAVING COUNT(*) > 1;

postgres=# CREATE TABLE product_reviews (
    review_id SERIAL PRIMARY KEY,
    product_id INT NOT NULL,
    rating DECIMAL(3, 1) NOT NULL,
    review_text TEXT,
    review_date DATE NOT NULL
);
CREATE TABLE
postgres=# INSERT INTO product_reviews (product_id, rating, review_text, review_date) VALUES
(101, 4.5, 'Great product!', '2023-01-15'),
(101, 4.8, 'Highly recommended.', '2023-02-20'),
(101, 3.5, 'Not bad.', '2023-03-10');
INSERT 0 3

postgres=# -- Find products with average rating above 4.0
SELECT
product_id,
AVG(rating) AS avg_rating,
COUNT(*) AS review_count
FROM product_reviews
GROUP BY product_id
HAVING AVG(rating) > 4.0 AND COUNT(*) >= 3;
 product_id |     avg_rating     | review_count 
------------+--------------------+--------------
        101 | 4.2666666666666667 |            3
(1 row)

postgres=# -- Aggregate function: Returns one row per department
SELECT department, AVG(salary) AS dept_avg_salary
FROM employees
GROUP BY department;
 department |  dept_avg_salary   
------------+--------------------
 Sales      | 67500.000000000000
 IT         | 67500.000000000000
 HR         | 60000.000000000000
(3 rows)

postgres=# -- Window function: Returns all rows with department average
SELECT
id,
name,
department,
salary,
AVG(salary) OVER (PARTITION BY department) AS dept_avg_salary
FROM employees;
 id |  name   | department |  salary  |  dept_avg_salary   
----+---------+------------+----------+--------------------
  6 | Frank   | HR         | 58000.00 | 60000.000000000000
  5 | Eve     | HR         | 62000.00 | 60000.000000000000
  3 | Charlie | IT         | 55000.00 | 67500.000000000000
  4 | David   | IT         | 80000.00 | 67500.000000000000
  2 | Bob     | Sales      | 75000.00 | 67500.000000000000
  1 | Alice   | Sales      | 60000.00 | 67500.000000000000
(6 rows)

postgres=# -- Aggregate functions handle NULL values in specific ways:
-- COUNT(*) includes NULLs, COUNT(column) excludes NULLs
SELECT
COUNT(*) AS total_rows,
COUNT(email) AS non_null_emails,
COUNT(*) - COUNT(email) AS null_emails
FROM employees;
 total_rows | non_null_emails | null_emails 
------------+-----------------+-------------
          6 |               2 |           4
(1 row)

postgres=# -- Aggregate functions handle NULL values in specific ways:
-- COUNT(*) includes NULLs, COUNT(column) excludes NULLs
SELECT
COUNT(*) AS total_rows,
COUNT(email) AS non_null_emails,
COUNT(*) - COUNT(email) AS null_emails
FROM employees;
 total_rows | non_null_emails | null_emails 
------------+-----------------+-------------
          6 |               2 |           4
(1 row)

postgres=# ALTER TABLE employees ADD COLUMN bonus INT;
ALTER TABLE
postgres=# UPDATE employees SET bonus=5000 WHERE id IN (1,3,5);
UPDATE 3
postgres=# -- SUM, AVG, MAX, MIN ignore NULL values
SELECT
SUM(bonus) AS total_bonus, -- NULLs ignored
AVG(bonus) AS avg_bonus, -- NULLs ignored
COUNT(bonus) AS employees_with_bonus
FROM employees;
 total_bonus |       avg_bonus       | employees_with_bonus 
-------------+-----------------------+----------------------
       15000 | 5000.0000000000000000 |                    3
(1 row)

SELECT
department,
COUNT(*) AS employee_count,
MIN(salary) AS min_salary,
MAX(salary) AS max_salary,
AVG(salary) AS avg_salary,
STDDEV(salary) AS salary_std_dev
FROM employees
GROUP BY department
ORDER BY avg_salary DESC;

 department | employee_count | min_salary | max_salary |     avg_salary     |   salary_std_dev   
------------+----------------+------------+------------+--------------------+--------------------
 Sales      |              2 |   60000.00 |   75000.00 | 67500.000000000000 | 10606.601717798213
 IT         |              2 |   55000.00 |   80000.00 | 67500.000000000000 |     17677.66952966
 HR         |              2 |   58000.00 |   62000.00 | 60000.000000000000 |  2828.427124746190
(3 rows)


postgres=# SELECT
department,
COUNT(*) AS total_employees,
COUNT(CASE WHEN salary > 50000 THEN 1 END) AS high_earners,
COUNT(CASE WHEN hire_date > '2023-01-01' THEN 1 END) AS recent_hires
FROM employees
GROUP BY department;
 department | total_employees | high_earners | recent_hires 
------------+-----------------+--------------+--------------
 Sales      |               2 |            2 |            2
 IT         |               2 |            2 |            1
 HR         |               2 |            2 |            0
(3 rows)


postgres=# SELECT
department,
COUNT(*) AS total_employees,
COUNT(CASE WHEN salary > 50000 THEN 1 END) AS high_earners,
COUNT(CASE WHEN hire_date > '2023-01-01' THEN 1 END) AS recent_hires
FROM employees
GROUP BY department;
 department | total_employees | high_earners | recent_hires 
------------+-----------------+--------------+--------------
 Sales      |               2 |            2 |            2
 IT         |               2 |            2 |            1
 HR         |               2 |            2 |            0
(3 rows)


postgres=# -- Calculate percentage of total
SELECT
department,
COUNT(*) AS dept_count,
COUNT(*)::FLOAT / (SELECT COUNT(*) FROM employees) * 100 AS
percentage
FROM employees
GROUP BY department
ORDER BY percentage DESC;
 department | dept_count |    percentage     
------------+------------+-------------------
 Sales      |          2 | 33.33333333333333
 IT         |          2 | 33.33333333333333
 HR         |          2 | 33.33333333333333
(3 rows)
